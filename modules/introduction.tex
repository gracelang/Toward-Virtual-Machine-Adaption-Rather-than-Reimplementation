%!TEX root = ../paper.tex

% ---------------------------------------------------------------------------- %
% Outline

\iftoggle{outline}{

    \begin{itemize}
        \item VMs are good
        \item Hard to build, even with VM gramworks like Truffle \& pypy
        \item Makes it hard for a new langauge to get a VM
        \item We are exploring making a VM for Grace by adapting VM for NS
        \item initial results are positive
    \end{itemize}

}{}

% 
% ---------------------------------------------------------------------------- %

\sm{The use of macros seems highly over-engineered...}
\sm{and, you might like the xspace package, I think, to avoid always having to put braces at the end}

\listRecentVmFrameworks{}, two recent \ugh{\vmframeworks{}, provide a \hostvm{}}\sm{I feel this characterization is not quite accurate.
At least for RPython, each interpreter gets its own VM generated.
With Truffle, we indeed reuse the JVM as a host VM.} that implements a \hll{}. %\LanguageDevs{} can use to \hostvm{} to create a new \vm{} that is tailored to their own \pls{}.
\sm{ambiguous wording:}
\del{Beyond offering a \hll{} for implementation,}
The \hostvm{} can also offer features such as \gb{}, \jitting{}, and other \optimizations{}. Unsurprisingly, \sm{no capital: perhaps better also no macro?}\LanguageDevs{} have already used the \frameworks{} to successfully implement popular \oopl{}, such as \Python{}, \Ruby{}, \Javascript{}, and more, with performance results comparable to that of the \ugh{monolithic bytecode \interps{}}\sm{no, much better, as good as state of the art JITing vms}\citep{Marr2015,Marr:2016:AWFY}.

% Object storage is provided by truffle, so, the fact that SOMns has its own is somewhat an artifact of ‘history’, and perhaps somewhat an optimization/step to avoid dependence on closed-source Oracle features. There are other aspects like storage strategies (think of our arrays), which haven’t been included in truffle yet, but are for instance in RPython: 
% -- http://dl.acm.org/citation.cfm?id=2816716

Despite the multitude of \tvms{} that have been developed using \vmframeworks{}, it appears that \languageDevs{} tend to recreate similar components (\listVmComponents{}\sm{really not a fan of macros.
This makes editing really hard!}) \emph{on-top-of} the \framework{} rather than reuse the existing implementations from other \tvms{}; perhaps gaining fine-grained control over later optimizations at the cost of a significant amount of work.

% People are playing with these ideas
% -- Product Lines of Interpreters Using Truffle with Object Algebras
% -- Modular interpreters for the masses: implicit context propagation using object algebras

Recently, the notion of developing a set of component that can be easily extended to create a \tvm{} have gained traction. For example, \rcitea{WoB2014} introduced a robust \objectstorage{} model, which has now been intergrated into the \Truffle{} \framework{}; and \rcite{Inostroza2015} introduce reusable components for languages with \denotationalSemantics{} using \emph{\ObjectAlgebras{}} \rcite{Oliveira2012}.

We propose to explore the potential for robustly implemented \tvms{} to serve as themselves as an extensible \frameworks{} for reuse, through an experiment where we adapt \textsc{\SOMns{}} to realize a \GraceVM{}.


%
% ---------------------------------------------------------------------------- %



% ---------------------------------------------------------------------------- %
% Notes

% The original idea of a \emph{\vm{}} was a tool that compiled a program from an abstract into machine executable code, useful in that \languageDevs{} could implement a method to parse their language into the \ir{} understood by the \vm{}. 

    % Stefan - I don’t think so, p-code might be the first example of a virtual machine. There was no translation, it was just to avoid targeting a specific hardware machine, because back then they had many more different architectures than 3-4 people care about today



% An \interp{} is collections of tools for executing a program. \lexing{} encodes an \ir{} with the logic of the program and then that representation is visited to realize execution. From its outset, practitioners have created a multitude of different \interps{} for different languages, each with a toolkit based on similar conventions but unique in its implementation (often required to support the semantics of the language being interpreted). 

% 
% ---------------------------------------------------------------------------- %