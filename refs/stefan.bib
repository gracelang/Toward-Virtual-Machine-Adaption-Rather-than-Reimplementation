@inproceedings{Castanos2012,
  author = {Castanos, Jose and Edelsohn, David and Ishizaki, Kazuaki and Nagpurkar, Priya and Nakatani, Toshio and Ogasawara, Takeshi and Wu, Peng},
  booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
  doi = {10.1145/2384616.2384631},
  isbn = {978-1-4503-1561-6},
  keywords = {languages python scripting},
  location = {Tucson, Arizona, USA},
  numpages = {18},
  pages = {195--212},
  publisher = {ACM},
  series = {OOPSLA '12},
  title = {On the Benefits and Pitfalls of Extending a Statically Typed Language JIT Compiler for Dynamic Scripting Languages},
  year = 2012
}

@article{Bolz2013,
  abstract = {Most modern languages are implemented using Virtual Machines (VMs). While the best \{VMs\} use Just-In-Time (JIT) compilers to achieve good performance, \{JITs\} are costly to implement, and few \{VMs\} therefore come with one. The \{RPython\} language allows tracing \{JIT\} \{VMs\} to be automatically created from an interpreter, changing the economics of \{VM\} implementation. In this paper, we explain, through two concrete VMs, how meta-tracing \{RPython\} \{VMs\} can be designed and optimised, and, experimentally, the performance levels one might reasonably expect from them. },
  author = {Bolz, Carl Friedrich and Tratt, Laurence},
  description = {The impact of meta-tracing on VM design and implementation},
  doi = {10.1016/j.scico.2013.02.001},
  issn = {0167-6423},
  journal = {Science of Computer Programming },
  keywords = {LanguageImplementation MetaTracing PyPy RPython Tracing VMs VirtualMachine},
  title = {The Impact of Meta-Tracing on VM Design and Implementation},
  year = 2013
}

@inproceedings{Marr2015,
  abstract = {Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs.

This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object-oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.},
  author = {Marr, Stefan and Ducasse, St√©phane},
  booktitle = {Proceedings of the 2015 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
  doi = {10.1145/2660193.2660194},
  isbn = {978-1-4503-2585-1},
  keywords = {Compiler Interpreter JITCompilation MeMyPublication MetaTracing Optimization PartialEvaluation RPython SelfOptimizing Tracing Truffle myown},
  numpages = {19},
  pages = {821--839},
  pdf = {http://stefan-marr.de/downloads/oopsla15-marr-ducasse-meta-tracing-vs-partial-evaluation.pdf},
  publisher = {ACM},
  series = {OOPSLA '15},
  title = {Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters},
  year = 2015
}

@inproceedings{Wimmer2012,
  abstract = {Modularity is a key concept for large and complex applications and an important enabler for collaborative research. In comparison, virtual machines (VMs) are still mostly monolithic pieces of software. Our goal is to significantly reduce to the cost of extending VMs to efficiently host and execute multiple, dynamic languages. We are designing and implementing a VM following the "everything is extensible" paradigm. Among the novel use cases that will be enabled by our research are: VM extensions by third parties, support for multiple languages inside one VM, and a universal VM for mobile devices. Our research will be based on the existing state of the art. We will reuse an existing metacircular Java VM and an existing dynamic language VM implemented in Java. We will split the VMs into fine-grained modules, define explicit interfaces and extension points for the modules, and finally re-connect them. Performance is one of the most important concerns for VMs. Modularity improves flexibility but can introduce an unacceptable performance overhead at the module boundaries, e.g., for inter-module method calls. We will identify this overhead and address it with novel feedback-directed compiler optimizations. These optimizations will also improve the performance of modular applications running on top of our VM. The expected results of our research will be not only new insights and a new design approach for VMs, but also a complete reference implementation of a modular VM where everything is extensible by third parties and that supports multiple languages.},
  author = {Wimmer, Christian and Brunthaler, Stefan and Larsen, Per and Franz, Michael},
  booktitle = {Proceedings of the 11th Annual International Conference on Aspect-oriented Software Development},
  description = {Fine-grained modularity and reuse of virtual machine components},
  doi = {10.1145/2162049.2162073},
  isbn = {978-1-4503-1092-5},
  keywords = {JIT JVM Java Maxine MetaCircular Modularity Modules Proposal Research VM},
  location = {Potsdam, Germany},
  numpages = {12},
  pages = {203--214},
  publisher = {ACM},
  series = {AOSD '12},
  title = {Fine-grained Modularity and Reuse of Virtual Machine Components},
  year = 2012
}

