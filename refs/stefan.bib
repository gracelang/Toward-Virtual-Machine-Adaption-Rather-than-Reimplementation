
@inproceedings{Castanos2012,
  author       = {Castanos, Jose and Edelsohn, David and Ishizaki, Kazuaki and Nagpurkar, Priya and Nakatani, Toshio and Ogasawara, Takeshi and Wu, Peng},
  Xbooktitle   = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
  Xdoi         = {10.1145/2384616.2384631},
  Xisbn        = {978-1-4503-1561-6},
  Xkeywords    = {languages python scripting},
  Xlocation    = {Tucson, Arizona, USA},
  Xnumpages    = {18},
  pages        = {195--212},
  Xpublisher   = {ACM},
  Xseries      = {OOPSLA '12},
  title        = {On the Benefits and Pitfalls of Extending a Statically Typed Language JIT Compiler for Dynamic Scripting Languages},
  year         = 2012
}

@article{Bolz2013,
  Xabstract    = {Most modern languages are implemented using Virtual Machines (VMs). While the best \{VMs\} use Just-In-Time (JIT) compilers to achieve good performance, \{JITs\} are costly to implement, and few \{VMs\} therefore come with one. The \{RPython\} language allows tracing \{JIT\} \{VMs\} to be automatically created from an interpreter, changing the economics of \{VM\} implementation. In this paper, we explain, through two concrete VMs, how meta-tracing \{RPython\} \{VMs\} can be designed and optimised, and, experimentally, the performance levels one might reasonably expect from them. },
  author       = {Bolz, Carl Friedrich and Tratt, Laurence},
  Xdescription = {The impact of meta-tracing on VM design and implementation},
  Xdoi         = {10.1016/j.scico.2013.02.001},
  Xissn        = {0167-6423},
  journal      = {Science of Computer Programming },
  Xkeywords    = {LanguageImplementation MetaTracing PyPy RPython Tracing VMs VirtualMachine},
  title        = {The Impact of Meta-Tracing on VM Design and Implementation},
  year         = 2013
}

@inproceedings{Marr2015,
  Xabstract    = {Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs. This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object-oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.},
  author       = {Marr, Stefan and Ducasse, Stéphane},
  Xbooktitle   = {Proceedings of the 2015 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
  Xdoi         = {10.1145/2660193.2660194},
  Xisbn        = {978-1-4503-2585-1},
  Xkeywords    = {Compiler Interpreter JITCompilation MeMyPublication MetaTracing Optimization PartialEvaluation RPython SelfOptimizing Tracing Truffle myown},
  Xnumpagesq   = {19},
  Xpages       = {821--839},
  Xpdf         = {http://stefan-marr.de/downloads/oopsla15-marr-ducasse-meta-tracing-vs-partial-evaluation.pdf},
  Xpublisher   = {ACM},
  series       = {OOPSLA '15},
  title        = {Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters},
  year         = 2015
}

@inproceedings{Wimmer2012,
  Xabstract    = {Modularity is a key concept for large and complex applications and an important enabler for collaborative research. In comparison, virtual machines (VMs) are still mostly monolithic pieces of software. Our goal is to significantly reduce to the cost of extending VMs to efficiently host and execute multiple, dynamic languages. We are designing and implementing a VM following the "everything is extensible" paradigm. Among the novel use cases that will be enabled by our research are: VM extensions by third parties, support for multiple languages inside one VM, and a universal VM for mobile devices. Our research will be based on the existing state of the art. We will reuse an existing metacircular Java VM and an existing dynamic language VM implemented in Java. We will split the VMs into fine-grained modules, define explicit interfaces and extension points for the modules, and finally re-connect them. Performance is one of the most important concerns for VMs. Modularity improves flexibility but can introduce an unacceptable performance overhead at the module boundaries, e.g., for inter-module method calls. We will identify this overhead and address it with novel feedback-directed compiler optimizations. These optimizations will also improve the performance of modular applications running on top of our VM. The expected results of our research will be not only new insights and a new design approach for VMs, but also a complete reference implementation of a modular VM where everything is extensible by third parties and that supports multiple languages.},
  author       = {Wimmer, Christian and Brunthaler, Stefan and Larsen, Per and Franz, Michael},
  Xbooktitle   = {Proceedings of the 11th Annual International Conference on Aspect-oriented Software Development},
  Xdescription = {Fine-grained modularity and reuse of virtual machine components},
  Xdoi         = {10.1145/2162049.2162073},
  Xisbn        = {978-1-4503-1092-5},
  Xkeywords    = {JIT JVM Java Maxine MetaCircular Modularity Modules Proposal Research VM},
  Xlocation    = {Potsdam, Germany},
  Xnumpages    = {12},
  Xpages       = {203--214},
  Xpublisher   = {ACM},
  Xseries      = {AOSD '12},
  title        = {Fine-grained Modularity and Reuse of Virtual Machine Components},
  year         = 2012
}

@inproceedings{Marr:2016:AWFY,
  abstract = {Comparing the performance of programming languages is difficult because they differ in many aspects including preferred programming abstractions, available frameworks, and their runtime systems. Nonetheless, the question about relative performance comes up repeatedly in the research community, industry, and wider audience of enthusiasts.

This paper presents 14 benchmarks and a novel methodology to assess the compiler effectiveness across language implementations. Using a set of common language abstractions, the benchmarks are implemented in Java, JavaScript, Ruby, Crystal, Newspeak, and Smalltalk. We show that the benchmarks exhibit a wide range of characteristics using language-agnostic metrics. Using four different languages on top of the same compiler, we show that the benchmarks perform similarly and therefore allow for a comparison of compiler effectiveness across languages. Based on anecdotes, we argue that these benchmarks help language implementers to identify performance bugs and optimization potential by comparing to other language implementations.},
  author = {Marr, Stefan and Daloze, Benoit and Mössenböck, Hanspeter},
  booktitle = {Proceedings of the 12th Symposium on Dynamic Languages},
  doi = {10.1145/2989225.2989232},
  isbn = {978-1-4503-4445-6},
  keywords = {Benchmark Compiler Crystal Graal Java JavaScript MeMyPublication Metrics Newspeak NodeJS Performance Ruby Smalltalk Truffle myown},
  location = {Amsterdam, Netherlands},
  numpages = {12},
  pages = {120--131},
  pdf = {http://stefan-marr.de/downloads/dls16-marr-et-al-cross-language-compiler-benchmarking-are-we-fast-yet.pdf},
  publisher = {ACM},
  series = {DLS'16},
  title = {{Cross-Language Compiler Benchmarking---Are We Fast Yet?}},
  year = 2016
}

@presentation{stefanEventLoop,
  abstract = {Communicating Event-Loop Languages similar to E and AmbientTalk are recently gaining more traction as a subset of actor languages. With the rise of JavaScript, E’s notion of vats and non-blocking communication based on promises entered the mainstream. For implementations, the combination of dynamic typing, asynchronous message sending, and promise resolution pose new optimization challenges.

This paper discusses these challenges and presents initial experiments for a Newspeak implementation based on the Truffle framework. Our implementation is on average 1.65x slower than Java on a set of 14 benchmarks. Initial optimizations improve the performance of asynchronous messages and reduce the cost of encapsulation on microbenchmarks by about 2x. Parallel actor benchmarks further show that the system scales based on the workload characteristics. Thus, we conclude that Truffle is a promising platform also for communicating event-loop languages.},
  added-at = {2015-09-25T10:47:48.000+0200},
  author = {Marr, Stefan and Mössenböck, Hanspeter},
  biburl = {http://www.bibsonomy.org/bibtex/29f9881cc5d059f4916d4805e780b5e00/gron},
  booktitle = {Presentation at 5th International Workshop on Programming based on Actors, Agents, and Decentralized Control},
  day = 26,
  interhash = {0a0937a8e45344c88cbe6fb1ad8c42fa},
  intrahash = {9f9881cc5d059f4916d4805e780b5e00},
  keywords = {Actors Caching CommunicatingEventLoops Compiler Concurrency MeMyPublication Message Optimization PIC Sending Truffle myown},
  location = {Pittsburgh, PA, USA},
  month = {October},
  pdf = {http://stefan-marr.de/downloads/agere15-agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle.pdf},
  series = {AGERE '15},
  timestamp = {2015-09-25T11:39:02.000+0200},
  title = {Optimizing Communicating Event-Loop Languages with Truffle},
  type = {Work-in-Progress-Paper},
  url = {http://stefan-marr.de/papers/agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle/},
  year = 2015
}

@inproceedings{Wurthinger:2013:OVR,
  abstract = {Building high-performance virtual machines is a complex and expensive undertaking; many popular languages still have low-performance implementations. We describe a new approach to virtual machine (VM) construction that amortizes much of the effort in initial construction by allowing new languages to be implemented with modest additional effort. The approach relies on abstract syntax tree (AST) interpretation where a node can rewrite itself to a more specialized or more general node, together with an optimizing compiler that exploits the structure of the interpreter. The compiler uses speculative assumptions and deoptimization in order to produce efficient machine code. Our initial experience suggests that high performance is attainable while preserving a modular and layered architecture, and that new high-performance language implementations can be obtained by writing little more than a stylized interpreter.},
  acmid = {2509581},
  added-at = {2014-01-21T10:06:31.000+0100},
  author = {W\"{u}rthinger, Thomas and Wimmer, Christian and W\"{o}\ss, Andreas and Stadler, Lukas and Duboscq, Gilles and Humer, Christian and Richards, Gregor and Simon, Doug and Wolczko, Mario},
  biburl = {http://www.bibsonomy.org/bibtex/2b29e79b951e3cf138c348e4499ba5695/gron},
  booktitle = {Proceedings of the 2013 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
  description = {One VM to rule them all},
  doi = {10.1145/2509578.2509581},
  interhash = {9b0794c882d392a58ec3fd6c4dc3aaf5},
  intrahash = {b29e79b951e3cf138c348e4499ba5695},
  isbn = {978-1-4503-2472-4},
  keywords = {Graal Implementation Language Truffle VM VirtualMachine},
  location = {Indianapolis, Indiana, USA},
  numpages = {18},
  pages = {187--204},
  publisher = {ACM},
  series = {Onward!'13},
  timestamp = {2015-09-07T10:49:07.000+0200},
  title = {{One VM to Rule Them All}},
  year = 2013
}

